require 'json'

def normalize2(str)
  str = str.gsub(/[◇・〇＊△A□【】　＠♪]/, "")
  str.gsub!(/みじん切り/, "")
  return "" if (str.size == 0)
  str.gsub!(/鶏もも肉|鶏むね肉|鶏胸肉|鶏むね|鶏もも|鶏肉/, "とり肉")
  str.gsub!(/豚のこまぎれ|豚こまぎれ肉|豚こまぎれ|豚もも薄切り|豚薄切れ肉|豚薄切り肉|豚ばら薄切り|豚すらいす|豚小間肉|豚ばら肉|豚こま|豚肉/, "ぶた肉")
  str.gsub!("べーこん", "ベーコン")
  str.gsub!("人参", "にんじん")
  str.gsub!(/白米|お米|白ご飯|温かいご飯|御飯|あたたかいご飯|冷ご飯|米/, "ご飯")
  str.gsub!(/玉子|卵/, "たまご")
  str.gsub!(/新玉ねぎ|赤玉ねぎ|紫玉ねぎ|たまねぎ|玉葱/, "玉ねぎ")
  str.gsub!(/大蒜/, "にんにく")
  str.gsub!(/かっととまと缶|とまと缶|とまと/, "トマト")
  str.strip
end

def normalizeData()
  foods = []
  open("foods_extracted.json") do |io|
    foods = JSON.load(io)
  end
  foods.each do |food|
    ingredients = {}
    food["ingredients"].each do |key, val|
      normalized_key = normalize2(key)
      if normalized_key.size == 0 then
        next
      end
      if ingredients.include?(normalized_key) then
        ingredients[normalized_key] = ingredients[normalized_key] + val
      else
        ingredients[normalized_key] = val
      end
    end
    food["ingredients"] = ingredients
  end
  File.open("food_extracted_normalized.json", "w") do |f|
    f.write JSON.pretty_generate(foods)
  end
  foods
end

def readData()
  foods = []
  json = nil
  open("food_extracted_normalized.json") do |io|
    json = JSON.load(io)
  end
  json.each do |food|
    foods << food.each_with_object({}){|(k,v), h| h[k.to_sym] = v}
  end
  foods
end

normalizeData()
foods = readData()

load("put_description.rb")
threathold = 3
ingredient2food = {}
ing_pair_to_food = {}
food2ingredient = {}
food2description = {}
target_ingredients = ["とり肉", "ぶた肉", "ベーコン", "にんじん", "ご飯", "たまご", "牛乳", "玉ねぎ", "にんにく", "トマト"]
ng_foods = ["ケークサレ（塩ケーキ）", "ビリヤニ"]
known_foods = ['コロッケ', 'カレー', 'チャーハン', 'パスタ', 'グラタン', 'スープ'];
fallback_for_description = {
  "鶏丼" => "とりにくをご飯(ごはん)の上(うえ)にのせて，甘い(あまい)たれをかけた料理(りょうり)",
  "トマトクリーム" => "トマトと牛乳(ぎゅうにゅう)をまぜたソース",
  "パスタソース" => "パスタにからめて味(あじ)をつけるソース",
  "プリン" => "小麦粉(こむぎこ)、米(べい)、ラード、肉(にく)、卵(たまご)、牛乳(ぎゅうにゅう)、バター、果物(くだもの)などの材料(ざいりょう)を混ぜ(まぜ)て、砂糖(さとう)、塩(しお)などの調味料(ちょうみりょう)や香辛料(こうしんりょう)で味付け(あじつけ)し、煮(に)たり蒸し(むし)たり焼い(やい)たりして固め(かため)た料理(りょうり)",
  "スンドゥブチゲ" => "スンドゥブ・チゲは食堂(しょくどう)や家庭(かてい)で一般的(いっぱんてき)かつ安価(あんか)に親しま(したしま)れている鍋料理(なべりょうり)のひとつである。"
}

foods.each do |food|
  ingredients = []
  if food[:name].include?("アレンジ") or ng_foods.include?(food[:name])
    next
  end
  food[:ingredients].each do |key, val|
    if val >= threathold and target_ingredients.include?(key) then
      ingredients << key
    end
  end
  if ingredients.size >= 2 then
    ingredients.each do |ingredient|
      ingredient2food[ingredient] = (ingredient2food[ingredient] || []) << food[:name]
    end

    ingredients.sort!
    ingredients.each_with_index do |ingredient, index|
      ingredient2food[ingredient] = (ingredient2food[ingredient] || []) << food[:name]
      ingredients.each_with_index do |ingredient2, index2|
        next if index <= index2
        ing_pair_to_food[[ingredient, ingredient2]] = [] unless ing_pair_to_food[[ingredient, ingredient2]]
        ing_pair_to_food[[ingredient, ingredient2]] << food[:name]
      end
    end
    food2ingredient[food[:name]] = ingredients
    simple_name = food[:name].split("・")[0].split("（")[0]
    description = nil
    known_foods.each do |food_name|
      if simple_name.end_with?(food_name) then
        description = simple_name.gsub(food_name, "") + "の#{food_name}。" + put_furigana(fetch_description(simple_name))
        break
      end
    end
    unless description then
      description = put_furigana(fetch_description(simple_name))
    end
    if description.empty? then
      if fallback_for_description.has_key?(simple_name) then
        description = fallback_for_description[simple_name]
      else
        p "No description found for #{simple_name}"
      end
    end
    food2description[food[:name]] = description
  end
end

ingredient2food = ingredient2food.sort {|(k1, v1), (k2, v2)| v2.size <=> v1.size}

arr = []
ingredient2food.each do |item|
  arr << item[0]
end

ingredient2food.each do |item|
  item[0]
end

def loadCategoryList
  data = nil
  File.open("category_list.json") do |f|
    data = JSON.load(f)
  end
  data["result"]["small"]
end

def getFullId(categoryList, name)
  categoryList.each do |item|
    if item["categoryName"] === name
      return item["categoryUrl"].match(/[0-9\-]+/)[0]
    end
  end
end

# generate objC formatted output
out = []
ing_pair_to_food.each do |key, val|
  new_key = nil;
  if key[0] > key[1] then
    new_key = "#{key[1]}+#{key[0]}"
  else
    new_key = "#{key[0]}+#{key[1]}"
  end
  constructors = []
  categoryList = loadCategoryList
  val.each do |name|
    constructors << "[[TRFood alloc] initWithName:@\"#{name}\" id:@\"#{getFullId(categoryList, name)}\" andDescription:@\"#{food2description[name]}\"]"
  end 
  out << "@\"#{new_key}\" : @[#{constructors.join(', ')}]"
end

out.sort!
out = out.join(", \n")
File.open("out.txt", "w") do |f|
  f.write "//AutoGenerated using process.rb-----\nrecipesDictionary = @{#{out}\n};\n//----AutoGenerated\n"
end

