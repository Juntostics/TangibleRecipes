require 'json'

def normalize2(str)
  str = str.gsub(/[◇・〇＊△A□【】　＠♪]/, "")
  str.gsub!(/みじん切り/, "")
  return "" if (str.size == 0)
  str.gsub!(/鶏もも肉|鶏むね肉|鶏胸肉|鶏むね|鶏もも|鶏肉/, "とり肉")
  str.gsub!(/豚のこまぎれ|豚こまぎれ肉|豚こまぎれ|豚もも薄切り|豚薄切れ肉|豚薄切り肉|豚ばら薄切り|豚すらいす|豚小間肉|豚ばら肉|豚こま|豚肉/, "ぶた肉")
  str.gsub!("べーこん", "ベーコン")
  str.gsub!("人参", "にんじん")
  str.gsub!(/白米|お米|白ご飯|温かいご飯|御飯|あたたかいご飯|冷ご飯|米/, "ご飯")
  str.gsub!(/玉子|卵/, "たまご")
  str.gsub!(/新玉ねぎ|赤玉ねぎ|紫玉ねぎ|たまねぎ|玉葱/, "玉ねぎ")
  str.gsub!(/大蒜/, "にんにく")
  str.gsub!(/かっととまと缶|とまと缶|とまと/, "トマト")
  str.strip
end

def normalizeData()
  foods = []
  open("foods_extracted.json") do |io|
    foods = JSON.load(io)
  end
  foods.each do |food|
    ingredients = {}
    food["ingredients"].each do |key, val|
      normalized_key = normalize2(key)
      if normalized_key.size == 0 then
        next
      end
      if ingredients.include?(normalized_key) then
        ingredients[normalized_key] = ingredients[normalized_key] + val
      else
        ingredients[normalized_key] = val
      end
    end
    food["ingredients"] = ingredients
  end
  File.open("food_extracted_normalized.json", "w") do |f|
    f.write JSON.pretty_generate(foods)
  end
  foods
end

def readData()
  foods = []
  json = nil
  open("food_extracted_normalized.json") do |io|
    json = JSON.load(io)
  end
  json.each do |food|
    foods << food.each_with_object({}){|(k,v), h| h[k.to_sym] = v}
  end
  foods
end

normalizeData()
foods = readData()

threathold = 3
ingredient2food = {}
ing_pair_to_food = {}
food2ingredient = {}
target_ingredients = ["とり肉", "ぶた肉", "ベーコン", "にんじん", "ご飯", "たまご", "牛乳", "玉ねぎ", "にんにく", "トマト"]

foods.each do |food|
  ingredients = []
  food[:ingredients].each do |key, val|
    if val >= threathold and target_ingredients.include?(key) then
      ingredients << key
    end
  end
  if ingredients.size >= 2 then
    ingredients.each do |ingredient|
      ingredient2food[ingredient] = (ingredient2food[ingredient] || []) << food[:name]
    end

    ingredients.sort!
    ingredients.each_with_index do |ingredient, index|
      ingredient2food[ingredient] = (ingredient2food[ingredient] || []) << food[:name]
      ingredients.each_with_index do |ingredient2, index2|
        next if index <= index2
        ing_pair_to_food[[ingredient, ingredient2]] = [] unless ing_pair_to_food[[ingredient, ingredient2]]
        ing_pair_to_food[[ingredient, ingredient2]] << food[:name]
      end
    end
    food2ingredient[food[:name]] = ingredients
  end
end

ingredient2food = ingredient2food.sort {|(k1, v1), (k2, v2)| v2.size <=> v1.size}

arr = []
ingredient2food.each do |item|
  arr << item[0]
end

p arr
p arr.size

arr2 = []
p food2ingredient.keys

ingredient2food.each do |item|
  item[0]
end



def loadCategoryList
  data = nil
  File.open("category_list.json") do |f|
    data = JSON.load(f)
  end
  data["result"]["small"]
end

def getFullId(categoryList, name)
  categoryList.each do |item|
    if item["categoryName"] === name
      return item["categoryUrl"].match(/[0-9\-]+/)[0]
    end
  end
end

out = []
ing_pair_to_food.each do |key, val|
  new_key = nil;
  if key[0] > key[1] then
    new_key = "#{key[1]}+#{key[0]}"
  else
    new_key = "#{key[0]}+#{key[1]}"
  end
  constructors = []
  categoryList = loadCategoryList
  val.each do |name|
    constructors << "[[TRFood alloc] initWithName:@\"#{name}\" andId:@\"#{getFullId(categoryList, name)}\"]"
  end 
  out << "@\"#{new_key}\" : @[#{constructors.join(', ')}]"
end

out.sort!
out = out.join(", \n")
File.open("out.txt", "w") do |f|
  f.write "//AutoGenerated using process.rb-----\nrecipesDictionary = @{#{out}\n};\n//----AutoGenerated\n"
end

